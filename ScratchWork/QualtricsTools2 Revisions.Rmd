---
title: "QualtricsTools Data Table Export"
author: "Emma Morgan"
date: "8/19/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
devtools::load_all(".")
```

## QualtricsTools 2.0 Modern (Data Table) Export

Exploration for QualtricsTools 2.0 working with the data table (modern) export format
The legacy exporter is going away in 2021, so we need to update QualtricsTools accordingly.
Emma is trying to assess the workload required and how to best manage this.

Use the Long Exhaustive Sample Survey to try and be comprehensive. This is also well organized
Into the different types of questions. Emma may actually add additional question types and will need
to make sure the tests are updated to work with this well moving ahead to our new format.
Old QualtricsTools that works with the Legacy-unchecked-legacy (insights) and legacy 2 headerrows format
Will be available under an old preserved branch download. The new version will be designed to work
only with the current data table export of Qualtrics.

```{r loading-files, include=FALSE}

qsf_path <- here::here("data","Sample Surveys","Long Exhaustive 2","Long_Exhaustive_Sample_Survey2.qsf")
csv_lul <- here::here("data","Sample Surveys","Long Exhaustive 2","Long_Exhaustive2_LUL.csv")
csv_dt <- here::here("data","Sample Surveys","Long Exhaustive 2","Long_Exhaustive2_DT.csv")

survey <- ask_for_qsf(qsf_path)
#Can't jump straight to getting reorganzied questions and blocks since this includes processing results
valid_questions_blocks <- valid_questions_blocks_from_survey(survey)
questions <- valid_questions_blocks[["questions"]]
blocks <- valid_questions_blocks[["blocks"]]
#Get notes from the survey so we can add these to the questions
qtNotesList <- note_text_from_survey(survey)
#Add clean question text and human readable question type
#Insert notes and skip logic into questions
questions <- add_question_detail(questions = questions, blocks = blocks, qtNotesList = qtNotesList)
#Split side-by-side questions into their components and create space for the split questions within these blocks.
split_questions_blocks <- split_sbs_questions_blocks(questions = questions, blocks = blocks)
questions <- split_questions_blocks[['questions']]
blocks <- split_questions_blocks[['blocks']]

rm("valid_questions_blocks", "split_questions_blocks")

```

This section is going to look at loading the csv data file for the data table format. This will obviously
require changes from the previous format since we are changing the type of data being read in.

```{r load-csv-dt, include = FALSE}

responses <- readr::read_csv(csv_dt, col_types = readr::cols(.default = "c"))
responses[which(colnames(responses) == "")] <- NULL

original_first_rows <- responses[1:2,]
#Now we need to clean up the third row so it can be at all usable
#Write a function that can do this cleaning; then, in the future, we can just update this function
#instead of having to change the entire package again
clean_question_id <- function(qid) {
  qid_orig <- qid
  #Clean out the first part {"ImportId":"
  qid <- stringr::str_replace(qid, "^\\{\"ImportId\":\"","")
  #Clean out the end part
  qid <- stringr::str_replace(qid, "\"\\}$","")
  #Clean out the middle choiceId section
  qid <- stringr::str_replace(qid,"\",\"choiceId\":\"","_")
  return(qid)
}

#Now see what this has done

original_first_rows[2,] <- purrr::map(original_first_rows[2,], clean_question_id)
t(original_first_rows[2,])

#Now assign responses to be only the valid response columns
responses <- responses[3:nrow(responses),]
responses <- responses[apply(responses, 1, function(x) any(x != "")),]

#Changed this from just the apply so that it will return a tibble instead of a matrix; this may or may not matter 
responses <- tibble::as_tibble(apply(responses, 2, trimws))

```


Now we have managed to try and clean up the response import ids in new ways, so let's see if that has paid off at all with
what we are trying to do and whether we can link responses to questions


```{r link responses}

questions <- link_responses_to_questions(questions = questions,
                                           responses = responses,
                                           original_first_rows = original_first_rows)


```


The next steps after linking responses to questions would be processing question results.
Instead, add a step to create a codebook for each question based on the QSF alone. This should NOT 
need to involve the csv. If I can establish this step, it may also give Matthew (or Emma) more of a foundation to move forward with this.

The next section will show how to generate a codebook for each question type. This can then be functionalized and added 
to the setup process as an integral step of parsing the qsf.

```{r mcma_codebook_sample, include = FALSE}


#Going through the process_question_results question types since these are what we can work with
#numerical text answer - n/a

# multiple choice multiple answer
#  For this type, we don't really want a codebook as much as a mapping since it will always be "selected" and "unselected",
#  but we do at least want mapping from the variable name, choice value, recode value (if applicable), choice text

#Identify mcma_questions
mcma_questions <- questions[which(purrr::map_lgl(questions, is_mc_multiple_answer))]

#Start with Q15 - this has recode values
q <- mcma_questions[['Q15']][['Payload']]
q_choices <- purrr::map_chr(q[['Choices']],"Display")
q_choices <- purrr::map_chr(q_choices, clean_html_and_css)
q_choices <- tibble::tibble("ChoiceValue" = names(q_choices),
                            "ChoiceText" = q_choices)
q_recode_values <- tibble::tibble("ChoiceValue" = names(q[['RecodeValues']]),
                                     "RecodeValue" = unlist(q[['RecodeValues']]))
#Now we will still need to create a list of the variable names (Question Response Columns) to add to this
#The variable names will vary depending on whether or not recode values are used. If recode values are used,
#These appear in both the third row choiceID AND the first row variable names.
if ("RecodeValues" %in% names(q)) {
  q_varnames <- purrr::map_chr(q[['RecodeValues']], ~ stringr::str_c(q[['DataExportTag']],"_",.x))
  q_varnames <- tibble::tibble("ChoiceValue" = names(q_varnames),
                               "Question Response Column" = q_varnames)
} else {
  q_varnames <- stringr::str_c(q[['DataExportTag']],"_",names(q[['Choices']]))
  q_varnames <- tibble::tibble("ChoiceValue" = names(q[['Choices']]),
                               "Question Response Column" = q_varnames)
}
q_varnames

#Also should add a column for "TextEntry" to indicate whether a choice had text entry
#This will return "True" if the TextEntry selector is set to true; if there is not
#text entry selector indicated, replace the Null value with "false"
q_text_entry <- unlist(tidyr::replace_na(purrr::map(q[['Choices']],"TextEntry"),"false"))
q_text_entry <- tibble::tibble("ChoiceValue" = names(q_text_entry),
                               "TextEntry" = q_text_entry)

#Now bring all of these tables together
codebook <- dplyr::full_join(q_choices, q_varnames, by="ChoiceValue")
codebook <- dplyr::full_join(codebook, q_text_entry, by="ChoiceValue")
if ("RecodeValues" %in% names(q)) {
  codebook <- dplyr::full_join(codebook, q_recode_values, by="ChoiceValue")
}
#Now order so we have Question Response Column, choiceText, Choicevalue, then other columns
codebook <- dplyr::select(codebook, `Question Response Column`, `ChoiceText`, `ChoiceValue`, dplyr::everything())
codebook

```
       
Now I've created a codebook for one single question. Now, I would like to functionalize this so I can create a codebook for ANY 
multiple choice multiple answer question.

```{r clean_environment1, include=FALSE}

#Clean up the environment from everything that was created in the last section
rm("codebook", "mcma_questions", "q","q_choices", "q_recode_values", "q_text_entry", "q_varnames")

```

```{r mcma_codebook}

mcma_codebook <- function(question) {
  #Identify whether the question has recode values
  has_recode_values <- "RecodeValues" %in% names(question[['Payload']])
  
  #Generate table of choices
  q_choices <- sapply(question[['Payload']][['Choices']],function(x) x[["Display"]])
  q_choices <- sapply(q_choices, function(x) clean_html_and_css(x))
  q_choices <- tibble::tibble("ChoiceValue" = names(q_choices),
                              "ChoiceText" = unname(q_choices))
  
  #Generate a table of variable names (Question Response column)
  
  
  #Generate a table of recode values if recode values exist
  if (has_recode_values) {
    q_recode_values <- tibble::tibble("ChoiceValue" = names(question[['Payload']][['RecodeValues']]),
                                     "RecodeValue" = unname(unlist(question[['Payload']][['RecodeValues']])))
  }
  
  if (has_recode_values) {
    q_varnames <- purrr::map_chr(question[['Payload']][['RecodeValues']],
                                 ~ stringr::str_c(question[['Payload']][['DataExportTag']],"_",.x))
    q_varnames <- tibble::tibble("ChoiceValue" = names(q_varnames),
                                 "Question Response Column" = unname(q_varnames))
  } else {
    q_varnames <- stringr::str_c(question[["Payload"]][['DataExportTag']],"_",names(question[["Payload"]][['Choices']]))
    q_varnames <- tibble::tibble("ChoiceValue" = names(question[["Payload"]][['Choices']]),
                                 "Question Response Column" = unname(q_varnames))
  }
  
  #Generate a table indicating text entry presence for each choice
  #This will return "True" if the TextEntry selector is set to true; if there is not
  #text entry selector indicated, replace the Null value with "false"
  q_text_entry <- unlist(tidyr::replace_na(purrr::map(question[["Payload"]][['Choices']],"TextEntry"),"false"))
  q_text_entry <- tibble::tibble("ChoiceValue" = names(q_text_entry),
                               "TextEntry" = unname(q_text_entry))

  #Now bring all of these tables together to create the codebook
  codebook <- dplyr::full_join(q_choices, q_varnames, by="ChoiceValue")
  codebook <- dplyr::full_join(codebook, q_text_entry, by="ChoiceValue")
  
  if (has_recode_values) {
    codebook <- dplyr::full_join(codebook, q_recode_values, by="ChoiceValue")
  }
  
  #Now order so we have Question Response Column, choiceText, Choicevalue, then other columns
  codebook <- dplyr::select(codebook, `Question Response Column`, `ChoiceText`, `ChoiceValue`, dplyr::everything())
  
  #Add the codebook element to the question
  question[['Codebook']] <- codebook
  return(question)
  
}


```

Now that this is functionalized, we can try to see how it works with all of the mcma questions in this survey.

```{r generate_mcma_codebooks}

mcma_questions <- questions[which(purrr::map_lgl(questions, is_mc_multiple_answer))]

mcma_questions <- lapply(mcma_questions, function(x) mcma_codebook(x))
mcma_codebooks <- purrr::map(mcma_questions, "Codebook")

mcma_codebooks


```

It's an open question whether to include "Selected" and "Not selected", but I don't think this really matters in the codebook since 0/1 is descriptive
enough to indicate response presence. 

Next sep is going to be making codebooks for multiple choice single answer questions. We want to have similar columns to the other codebook. Then we just need to determine whether the recode values or actual values are being used. Processing responses has separate conditions for MCSA with N/A and 
MCSA without N/A, but this disctinction does not matter for purposes of the codebook.

```{r mcsa_codebook_sample, include=FALSE}

#Identify mcsa_questions
mcsa_questions <- questions[which(purrr::map_lgl(questions, is_mc_single_answer))]

#Start with Q7 - this has recode values and multiple text entry components
q <- mcsa_questions[['Q7']][['Payload']]
q_choices <- purrr::map_chr(q[['Choices']],"Display")
q_choices <- purrr::map_chr(q_choices, clean_html_and_css)
q_choices <- tibble::tibble("ChoiceValue" = names(q_choices),
                            "ChoiceText" = q_choices)
q_recode_values <- tibble::tibble("ChoiceValue" = names(q[['RecodeValues']]),
                                     "RecodeValue" = unlist(q[['RecodeValues']]))
#For this type of question, there is only a single column that corresponds to the DataExportTag.
#This makes it easier; the additional columns are for text entry components and will need to be dealt with
#later as we are creating text appendices
q_varname <- q[['DataExportTag']]

#Also should add a column for "TextEntry" to indicate whether a choice had text entry
#This will return "True" if the TextEntry selector is set to true; if there is not
#text entry selector indicated, replace the Null value with "false"
q_text_entry <- unlist(tidyr::replace_na(purrr::map(q[['Choices']],"TextEntry"),"false"))
q_text_entry <- tibble::tibble("ChoiceValue" = names(q_text_entry),
                               "TextEntry" = q_text_entry)

#Now bring all of these tables together
codebook <- dplyr::full_join(q_choices, q_text_entry, by="ChoiceValue")

if ("RecodeValues" %in% names(q)) {
  codebook <- dplyr::full_join(codebook, q_recode_values, by="ChoiceValue")
}
#Add in the question response column
codebook <- dplyr::mutate(codebook, `Question Response Column` = q[['DataExportTag']])
#Add in an actual "value" column that takes either the choice value or recode value
if ("RecodeValues" %in% names(q)) {
  codebook <- dplyr::mutate(codebook, "Value" = RecodeValue)
} else codebook <- dplyr::mutate(codebook, "Value" = ChoiceValue)
#Now order so we have Question Response Column, choiceText, Choicevalue, then other columns
codebook <- dplyr::select(codebook, `Question Response Column`, Value, "ValueLabel" = `ChoiceText`, TextEntry, `ChoiceValue`, dplyr::everything())

codebook


```

```{r clean_environment2, include=FALSE}

rm("mcsa_questions", "q", "q_choices", "q_recode_values", "q_text_entry", "codebook")

```


Now that we have created the codebook, functionalize this so that we can easily create codebooks for mutiple choice
single answer type questions.

```{r mcsa_codebook}
mcsa_codebook <- function(question) {
  
  has_recode_values <- "RecodeValues" %in% names(question[['Payload']])
  
  q_choices <- purrr::map_chr(question[['Payload']][['Choices']],"Display")
  q_choices <- purrr::map_chr(q_choices, clean_html_and_css)
  q_choices <- tibble::tibble("ChoiceValue" = names(q_choices),
                              "ChoiceText" = q_choices)
  q_recode_values <- tibble::tibble("ChoiceValue" = names(question[['Payload']][['RecodeValues']]),
                                    "RecodeValue" = unlist(question[['Payload']][['RecodeValues']]))

  #Also should add a column for "TextEntry" to indicate whether a choice had text entry
  #This will return "True" if the TextEntry selector is set to true; if there is not
  #text entry selector indicated, replace the Null value with "false"
  q_text_entry <- unlist(tidyr::replace_na(purrr::map(question[['Payload']][['Choices']],"TextEntry"),"false"))
  q_text_entry <- tibble::tibble("ChoiceValue" = names(q_text_entry),
                                 "TextEntry" = q_text_entry)
  
  #Now bring all of these tables together
  codebook <- dplyr::full_join(q_choices, q_text_entry, by="ChoiceValue")
  
  if (has_recode_values) {
    codebook <- dplyr::full_join(codebook, q_recode_values, by="ChoiceValue")
  }
  #Add in the question response column
  codebook <- dplyr::mutate(codebook, `Question Response Column` = question[['Payload']][['DataExportTag']])
  #Add in an actual "value" column that takes either the choice value or recode value
  if (has_recode_values) {
    codebook <- dplyr::mutate(codebook, "Value" = RecodeValue)
  } else codebook <- dplyr::mutate(codebook, "Value" = ChoiceValue)
  #Now order so we have Question Response Column, choiceText, Choicevalue, then other columns
  codebook <- dplyr::select(codebook, `Question Response Column`, Value, 
                            "ValueLabel" = `ChoiceText`, TextEntry, `ChoiceValue`, dplyr::everything())
  
  question[["Codebook"]] <- codebook
  return(question)
}

```

Now that the multiple choice single answer codebook is functionalized, 
we can try to see how it works with all of the mcma questions in this survey.

```{r generate_mcsa_codebooks}

mcsa_questions <- questions[which(purrr::map_lgl(questions, is_mc_single_answer))]

mcsa_questions <- lapply(mcsa_questions, function(x) mcsa_codebook(x))
mcma_codebooks <- purrr::map(mcsa_questions, "Codebook")

mcma_codebooks


```


<!-- else if (is_mc_multiple_answer(question)) { -->
<!--   if (should_use_ofr) { -->
<!--     question <- -->
<!--       mc_multiple_answer_results(question, original_first_rows) -->
<!--   } else { -->
<!--     question <- mc_multiple_answer_results(question) -->
<!--   } -->

<!--   # multiple choice single answer with NA type choice -->
<!-- } else if(is_mc_single_answer(question) && has_na(question)){ -->
<!--   if (should_use_ofr) { -->
<!--     question <- -->
<!--       matrix_single_answer_results(question, original_first_rows) -->
<!--   } else { -->
<!--     question <- matrix_single_answer_results(question) -->
<!--   } -->

<!--   # regular multiple choice single answer -->
<!-- } else if(is_mc_single_answer(question) && !has_na(question)){ -->
<!--   if (should_use_ofr) { -->
<!--     question <- mc_single_answer_results(question, original_first_rows) -->
<!--   } else { -->
<!--     question <- mc_single_answer_results(question) -->
<!--   } -->

<!--   # matrix multiple answer -->
<!-- } else if (is_matrix_multiple_answer(question)) { -->
<!--   if (should_use_ofr) { -->
<!--     question <- -->
<!--       matrix_multiple_answer_results(question, original_first_rows) -->
<!--   } else { -->
<!--     question <- matrix_multiple_answer_results(question) -->
<!--   } -->

<!--   # matrix single answer -->
<!-- } else if (is_matrix_single_answer(question)) { -->
<!--   if (should_use_ofr) { -->
<!--     question <- -->
<!--       matrix_single_answer_results(question, original_first_rows) -->
<!--   } else { -->
<!--     question <- matrix_single_answer_results(question) -->
<!--   } -->
<!-- } -->
<!-- }, silent = TRUE) -->



